---
title: Abusing Scope
description: How to reduce function complexity by abusing the scope of variables.
---

Have you ever worked in functions that referenced global variables, or in functions that declared a ton of variables at the top? How hard were they to follow?

Years ago I read [The Magical Number Seven, Plus or Minus Two](https://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two), which explains that we can only keep about 7±2 things in working memory. Every variable in a scope is one more thing to track.

*Scope* is where a variable can be read or changed. By narrowing scope, we shrink how much we have to hold in our heads and make the code easier to understand. Here are a few ways to "abuse scope" to do that.

## Moving variables down

In synchronous code, you can't use a variable before it's declared. So it's common to declare everything at the top of a function so the rest of the code can use it.

```ts
const prepareFeast = () => {
    // All of the variables, nicely grouped together at the top.
    const fruit = "cranberry";
    const pastry = "pie crust";
    const protein = "chicken";
    const sauce = "gravy";
    const starch = "potato";
    const sweetener = "sugar";
    const vegetable = "romaine lettuce";

    const pie = bakePie({
        ingredients: [fruit, pastry, sweetener],
    });
    const salad = makeSalad({
        ingredients: [fruit, protein, vegetable],
    });
    const dinner = makeDinner({
        ingredients: [protein, sauce, starch, vegetable],
    });
};
```

If we declare each variable as close as possible to where it's used, fewer variables are in scope at any given moment—so there's less to keep in your head while reading the top of the function.

```ts
const prepareFeast = () => {
    const fruit = "cranberry";
    const pastry = "pie crust";
    const sweetener = "sugar";

    const pie = bakePie({
        ingredients: [fruit, pastry, sweetener],
    });

    // These aren't used when baking a pie
    const protein = "chicken";
    const vegetable = "romaine lettuce";

    const salad = makeSalad({
        ingredients: [fruit, protein, vegetable],
    });

    // These aren't used when baking a pie and making a salad
    const sauce = "gravy";
    const starch = "potato";

    const dinner = makeDinner({
        ingredients: [protein, sauce, starch, vegetable],
    });
};
```

## Using .then() in async functions

We usually add `async` to a function to avoid callback-based async code ([callback hell](https://callbackhell.com/)).

```ts title="this-used-to-suck.ts"
const createUser = (
    userId: string,
    callback: (user: User | null, err: Error | null) => void,
) => {
    db.findUsers({ id: userId }, (rows, err) => {
        if (err) {
            callback(null, err);
            return;
        }

        const user = rows[0];
        if (user) {
            callback(user, null);
            return;
        }

        db.createUser(
            { id: userId, name: "John Doe" },
            callback
        );
    });
};
```

```ts title="this-is-simpler.ts"
const createUser = async (
    userId: string
) => {
    // `rows` is only used to derive `user`
    const rows = await db.findUsers({ id: userId });
    const user = rows[0] ?? null;

    if (user) return user;

    return await db.createUser({
        id: userId,
        name: "John Doe",
    });
```

Even with `async`, a `.then()` callback can help: it lets you avoid adding a variable to the function scope when you only need it to compute a single value.

```ts title="this-is-even-simpler.ts"
const createUser = async (
    userId: string
) => {
    // No need to declare `rows` at the `createUser` scope.
    const user = await db
        .findUsers({ id: userId })
        .then((rows) => rows[0] ?? null);

    if (user) return user;

    return await db.createUser({
        id: userId,
        name: "John Doe",
    });
};
```

## Isolating a block: helper functions and IIFEs

Sometimes a chunk of logic needs several intermediate variables that the rest of the function never uses. You could declare them all in the same scope—or you could move that chunk into its own scope so those variables never leave the block. Two ways to do that: a **helper function** or an [**IIFE**](https://developer.mozilla.org/en-US/docs/Glossary/IIFE) (immediately invoked function expression).

```ts
const processRequest = (req: Request) => {
    const body = readBody(req);

    const parsed = JSON.parse(body);
    const validated = validateSchema(parsed);
    const result = runBusinessLogic(validated);

    logger.info("Processed", { id: req.id });
    return sendResponse(result);
};
```

Here, `parsed` and `validated` exist for the whole function even though they're only used to get `result`. A helper function gives them their own scope and a name that describes the step:

```ts
const processRequest = (req: Request) => {
    const body = readBody(req);
    const result = parseAndRun(body);

    logger.info("Processed", { id: req.id });
    return sendResponse(result);
};

function parseAndRun(body: string) {
    const parsed = JSON.parse(body);
    const validated = validateSchema(parsed);
    return runBusinessLogic(validated);
}
```

If that logic is only used once and doesn't need a name, an IIFE does the same thing without leaving the function:

```ts
const processRequest = (req: Request) => {
    const body = readBody(req);
    const result = (() => {
        const parsed = JSON.parse(body);
        const validated = validateSchema(parsed);
        return runBusinessLogic(validated);
    })();

    logger.info("Processed", { id: req.id });
    return sendResponse(result);
};
```

Either way, the outer function only has to track `body` and `result`; the intermediates stay hidden.

## Wrapping up

Scope isn't just where names are valid—it's a way to limit how much the reader has to hold in mind at once. Declare variables near their use, use callbacks like `.then()` when they keep one-off values out of the outer scope, and isolate dense blocks with a helper function or an IIFE when you want to keep intermediates from leaking out. The goal is the same: fewer things in scope at any moment, so the code stays within that 7±2 and stays readable.
